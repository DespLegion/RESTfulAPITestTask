# Python REST API Test Task
## `FastAPI` + `Django ORM` + `Docker` + `Nginx` + `PostgreSQL`
_____________

### Задача:
Разработать `клиент-серверную (web)` систему согласно ТЗ с использованием `REST API`


### ТЗ к задаче:
#### Описание: 
Разработать систему добавления данных о качественных показателях железорудного концентрата и 
просмотра сводной информации по всем концентратам. 
Качественные показатели железорудного концентрата:
- содержание железа
- содержание кремния
- содержание алюминия
- содержание кальция
- содержание серы

#### Функциональные требования к системе:

1) Многопользовательская архитектура (достаточно 2х пользователей, делать страницы управления учетными записями не нужно, пользователи заранее внесены в БД).
2) Поддержка авторизации
3) Форма внесения данных должна представлять собой таблицу
4) Должен быть переключатель для выбора месяца
5) Форма для вноса данных должна поддерживать копирование\вставку из `Excel`. Предлагается использовать `Jspreadsheet`, но это на усмотрение разработчика.
6) Форма отчета должна выводить среднее, минимальное и максимальные значения по всем концентратам за выбранный месяц.
7) Бэк энд и фронт энд взаимодействуют на основе `REST API`.
8) Система реализована на `Docker`. `База данных`, `веб-сервер` и `сервер приложения` в отдельных контейнерах

_________________

### Отчет по задаче:

Поскольку проект небольшой, было принято решение использовать `FastAPI` для его реализации.
В пару к `FastAPI` было решено добавить `Django`, для использования исключительно функционала `Django Admin`
и `Django ORM`. `Django ORM` сильно упрощает взаимодействие с базой данных.

В качестве базы данных была выбрана `PostgreSQL`, как классический и один из самых распространенных вариантов.

Авторизация реализована при помощи `JWT`, без использования библиотек `FastAPI-Users` и подобных.
При запросе к API приложения источником `JWT` служит заголовок запроса (`Request Header`),
но если авторизация требуется при отображении `frontend` части, источником
`JWT` становятся `cookie` клиента.

`Frontend` реализован на голом `HTML` + `JavaScript`. Для отображения таблиц, как и было предложено используется `Jspreadsheet`.

Для отображения `Frontend'а` используется шаблонизатор `Jinja2`. 
Но, по условию задачи `Backend` и `Frontend` должны быть связаны исключительно по средствам `API`.
В связи с этим, от `Jinja2` была взята только возможность отображать шаблоны,
без дополнительного рендера и без передачи каких либо данных внутрь шаблона.
Все необходимые данные шаблоны получаются внутри себя используя `JavaScript` и запросы к `API` приложения.

Приложение упаковано в `Docker`. В качестве контейнера веб-сервера используется официальный образ `Nginx`.
Для базы данных используется официальный образ `PostgreSQL`.
Основой для контейнера приложения используется официальный образ `Python` в `slim` версии.
Благодаря `volumes` приложение развертывается с возможностью редактировать код
(файлы внутри контейнера приложения синхронизированы с файлами проекта), а благодаря
`uvicorn` и его атрибуту `--reload` приложение реагирует на изменение в файлах и автоматически
перезапускает сервер `uvicorn` применяя изменения, без необходимости пересобирать контейнер.

#### Endpoints:

Стандартные эндпоинты FastAPI с автоматически генерируемой документацией:

`/redoc`

`/docs` - `SWAGGER interface`

![](https://i.ibb.co/cXsPBbk/SWAGGER.jpg)

`/django/admin` - `Django Admin`

![](https://i.ibb.co/JKq4FFj/Django-admin.jpg)


##### API Endpoints:

`/api/login` - `POST` `API` для авторизации

`/api/register` - `POST` `API` для регистрации нового пользователя

`/api/create_mine` - `POST` `API` для создания новой Шахты

`/api/create_ore_concentration_note` - `POST` `API` для добавления новой записи о концентрации руды за конкретную дату

`/api/get_mines` - `GET` `API` для получения всех Шахт

`/api/get_ore_concentration_note` - `POST` `API` для получения записей о концентрации руды за определенные даты
(почему эндпоинт `POST`, а не `GET` объяснено в комментариях к коду)


##### Frontend endpoints:

`/login` - `GET` страница авторизации

![](https://i.ibb.co/2Z5nPCB/Login-page.jpg)

`/ore_stats` - `GET` страница просмотра записей о концентрации руд

![](https://i.ibb.co/c6DWk8W/get-conc-page.jpg)

`/create_note` - `GET` страница создания новых записей о концентрации руд

![](https://i.ibb.co/PxWvbw3/post-conc-page.jpg)


#### Все `API` эндпоинты (за исключением `frontend` эндпоинтов) тестировались при помощи `Postman`

Несколько скриншотов тестов `Postman`:

Успешная регистрация

![](https://i.ibb.co/KsQhzLv/postman-register.jpg)


Неудачная регистрация (пользователь с таким логином уже есть)

![](https://i.ibb.co/S0vZfQz/postman-bad-register.jpg)


Успешный логин

![](https://i.ibb.co/4WQDcJY/postman-login.jpg)


Неудачный логин

![](https://i.ibb.co/KWrfXXD/postman-bad-login.jpg)


Успешное получение записей о концентрации руд за определенный промежуток времени

![](https://i.ibb.co/DwPVfDH/postman-get-ore.jpg)


Неудачная попытка добавить новую запись о концентрации руд (Для это Шахты и на эту дату уже есть запись)

![](https://i.ibb.co/GHfNhDM/postman-bad-create-ore.jpg)

___________

### Развертывание приложения

1) Создать `.env` файл, следую образцу `.env_example`. 
(В целом значения указанные в `.env_example` являются верными значениями по умолчанию. Если вы не хотите менять какие либо настройки внутри проекта, то достаточно будет просто переименовать `.env_example` в `.env`)
2) Находясь в директории проекта использовать команду `docker-compose up -d`. После завершения процесса создания и монтирования контейнеров `Docker` проект станет доступен по адресу http://localhost:8000/.
(Напоминаю что перейдя по этому адресу вы получите исключение `FastAPI` - `Not Found`, ибо эндпоинт `/` не обрабатывается приложением.
Доступные эндпоинты указаны выше)
3) Для доступа к `Django Admin` (`/django/admin`) необходимо создать `супер-пользователя django`.
Для этого необходимо зайти в оболочку контейнера используя интерактивный режим (`docker exec -ti <container_id> bash`)
и выполнить команду `python manage.py createsuperuser`
4) Done! `:)`

______
